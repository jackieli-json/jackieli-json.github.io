<!DOCTYPE html><html class="theme-lattice"><head><meta charset="utf-8"><title>正则表达式实践篇 | 西门互联「西门互联」</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="西门互联"><meta name="designer" content="西门互联"><meta name="rating" content="general"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="index, follow"><meta name="keywords" content="多选分支,匹配分隔符之内的文本,匹配IP地址,匹配24小时制的时间,匹配美元,回溯,javascript,regexp,正则表达式,西门互联,前端,个人博客"><link rel="canonical" href="https://demo.lilidong.cn/notes/2016/12/07/regexp-practice/index.html"><link rel="apple-touch-icon" sizes="57x57" href="/img/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="114x114" href="/img/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="72x72" href="/img/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="144x144" href="/img/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="60x60" href="/img/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="120x120" href="/img/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="152x152" href="/img/apple-touch-icon-152x152.png"><link rel="icon" type="image/png" href="/img/favicon-230x230.png" sizes="230x230"><link rel="icon" type="image/png" href="/img/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/png" href="/img/favicon-16x16.png" sizes="16x16"><link rel="icon" type="image/png" href="/img/favicon-32x32.png" sizes="32x32"><meta name="msapplication-TileColor" content="#2f83cd"><meta name="msapplication-TileImage" content="/img/mstile-144x144.png"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/atom.xml" title="西门互联"><meta name="description" content="简单的练习：题目
与搜索字符串开始处的 3 个数字匹配。
与除 a、b 和 c 以外的任何字符匹配。
&amp;#39;1234567&amp;#39;.match(/\d{1,3}/g)的结果。
不以“th”开头的单词匹配。
对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字。
匹配一个中文字符。

答案
与搜索字符串开始处的 3 个数字匹配：/^\d{3}/。
与除 a、b"><meta property="og:type" content="article"><meta property="og:title" content="正则表达式实践篇"><meta property="og:url" content="https://demo.lilidong.cn/notes/2016/12/07/regexp-practice/index.html"><meta property="og:site_name" content="西门互联"><meta property="og:description" content="简单的练习：题目
与搜索字符串开始处的 3 个数字匹配。
与除 a、b 和 c 以外的任何字符匹配。
&amp;#39;1234567&amp;#39;.match(/\d{1,3}/g)的结果。
不以“th”开头的单词匹配。
对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字。
匹配一个中文字符。

答案
与搜索字符串开始处的 3 个数字匹配：/^\d{3}/。
与除 a、b"><meta property="og:image" content="https://demo.lilidong.cn//misc.aotu.io/Newcandy/2016-12-07-regexp-practice/24hour.png"><meta property="og:image" content="https://demo.lilidong.cn//misc.aotu.io/Newcandy/2016-12-07-regexp-practice/reg_input.png"><meta property="og:updated_time" content="2016-12-22T09:53:25.578Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="正则表达式实践篇"><meta name="twitter:description" content="简单的练习：题目
与搜索字符串开始处的 3 个数字匹配。
与除 a、b 和 c 以外的任何字符匹配。
&amp;#39;1234567&amp;#39;.match(/\d{1,3}/g)的结果。
不以“th”开头的单词匹配。
对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字。
匹配一个中文字符。

答案
与搜索字符串开始处的 3 个数字匹配：/^\d{3}/。
与除 a、b"><meta name="twitter:image" content="https://demo.lilidong.cn//misc.aotu.io/Newcandy/2016-12-07-regexp-practice/24hour.png"><meta name="twitter:site" content="o2circle"><script>var App={root:"/",isHome:!1,isCate:!1,isTag:!1}</script></head><body class="page-post-detail"><div class="mod-hd"><div class="grid"><div class="mod-logo"><a href="/index.html" title="西门互联">西门互联</a></div><span class="mod-hd-toggle" id="J_hdToggle"><i class="fa fa-bars"></i></span><div class="mod-hd-main"><div class="mod-hd-inner"><nav class="mod-nav"><ul class="mod-nav-list"><li class="main-nav-item"><a href="/index.html" class="main-nav-link">首页</a></li><li class="main-nav-item"><a href="/about/" class="main-nav-link">关于</a></li><li class="main-nav-item"><a href="/join/" class="main-nav-link">加入</a></li></ul></nav><div class="mod-search"><a class="fa fa-search mod-search-ico" id="J_searchTrigger" title="搜索"></a><form id="J_searchForm" method="get" class="mod-search-form" action="/search/"><input type="text" name="query" class="mod-search-ipt" id="J_searchInput" placeholder="搜索"></form></div></div></div></div></div><div class="mod-container"><div class="grid"><div class="mod-main"><article class="post"><header class="post-hd"><h2 class="post-tit">正则表达式实践篇</h2><div class="post-meta">by <a target="_blank" href="https://github.com/Newcandy" class="post-author">暖暖</a> on <span>2016-12-07</span></div><p class="post-subtit" style="display:none"><i class="fa fa-quote-left"></i>实践一下，才记得住杂七杂八的真知啊~</p><span style="display:none" id="busuanzi_value_page_pv"></span></header><div class="post-cover"><img src="//misc.aotu.io/Newcandy/2016-12-07-regexp-practice/cover_900x500.jpg" alt="正则表达式实践篇"></div><div class="post-content"><a id="more"></a><h2 id="简单的练习：" class="post-heading"><a href="#简单的练习：" class="headerlink" title="简单的练习："></a>简单的练习：<a class="post-anchor" href="#简单的练习：" aria-hidden="true"></a></h2><h3 id="题目" class="post-heading"><a href="#题目" class="headerlink" title="题目"></a>题目<a class="post-anchor" href="#题目" aria-hidden="true"></a></h3><ol><li>与搜索字符串开始处的 3 个数字匹配。</li><li>与除 a、b 和 c 以外的任何字符匹配。</li><li><code>&#39;1234567&#39;.match(/\d{1,3}/g)</code>的结果。</li><li>不以“th”开头的单词匹配。</li><li>对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字。</li><li>匹配一个中文字符。</li></ol><h3 id="答案" class="post-heading"><a href="#答案" class="headerlink" title="答案"></a>答案<a class="post-anchor" href="#答案" aria-hidden="true"></a></h3><ol><li>与搜索字符串开始处的 3 个数字匹配：<code>/^\d{3}/</code>。</li><li>与除 a、b 和 c 以外的任何字符匹配： <code>/[^abc]/</code>。</li><li>‘1234567’.match(/\d{1,3}/g)，根据贪婪原则，结果是 <code>[&quot;123&quot;, &quot;456&quot;, &quot;7&quot;]</code>。</li><li>不以“th”开头的单词匹配：<code>/\b(?!th)\w+\b/</code> 。</li><li>对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字： <code>/^(?=.*\d).{4,8}$/</code> 。首先.{4,8} 表示与包含 4-8 个字符的字符串匹配；然后.*表示单个字符（除换行符 \n 外）零次或多次，且后面跟着一个数字，注意(?=)只匹配一个位置。</li><li>匹配一个中文字符：<code>/[\u4e00-\u9fa5]/</code>。</li></ol><p>当然，可能答案不唯一，不必较真啦~ 主要目的是回忆熟悉一下语法~<br>如果还不了解正则，可以前往<a href="https://aotu.io/notes/2016/11/17/regexp-theory/" target="_blank" rel="external">正则表达式理论篇</a> 了解哇~</p><h2 id="真正的实践来了" class="post-heading"><a href="#真正的实践来了" class="headerlink" title="真正的实践来了"></a>真正的实践来了<a class="post-anchor" href="#真正的实践来了" aria-hidden="true"></a></h2><p>要想在复杂性和完整性之间取得平衡，一个重要因素是要<strong>了解将要搜索的文本</strong>。<br>好的正则表达式：</p><ul><li><strong>只匹配期望的文本，排除不期望的文本</strong>；</li><li><strong>易于控制和理解</strong>；</li><li><strong>保证效率</strong>。</li></ul><p>有时候处理各种极端情况会降低成本/收益的比例。所以某些情况下，不完全依赖正则表达式完成全部工作，比如某些字段用子表达式()括起来，让内存记忆下来，然后再用其他程序来验证。</p><p>不过本文还是从学习正则的角度出发，全部依赖正则表达式来写的哇~~</p><h2 id="匹配美元" class="post-heading"><a href="#匹配美元" class="headerlink" title="匹配美元"></a>匹配美元<a class="post-anchor" href="#匹配美元" aria-hidden="true"></a></h2><p>正则表达式：<code>/^\$[0-9]+(\.[0-9][0-9])?$/</code>。</p><p>分为四部分：</p><ul><li><code>^\$</code> 以美元符号开头。</li><li><code>[0-9]+</code> 至少包含一个数字。</li><li><code>(\.[0-9][0-9])?</code> 由一个点和两位数组成，匹配0次或1次，因为可能是整数或者是小数。</li><li><code>$</code> 最后的$表示以数字结尾的。</li></ul><p>缺点：不能匹配$1,000</p><h2 id="匹配24小时制的时间，比如-09-59" class="post-heading"><a href="#匹配24小时制的时间，比如-09-59" class="headerlink" title="匹配24小时制的时间，比如 09:59"></a>匹配24小时制的时间，比如 09:59<a class="post-anchor" href="#匹配24小时制的时间，比如-09-59" aria-hidden="true"></a></h2><ul><li><strong>小时部分</strong></li></ul><p><strong>方法一</strong>：分类逻辑为第一个数字(0、1、2)，可以分为三部分：上午 00点到09点（<strong>0可选</strong>）；白天10到19点；晚上20到23点。</p><p>因此有三个多选分支，得到的结果为：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>?[<span class="number">0</span><span class="number">-9</span>]|<span class="number">1</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">2</span>[<span class="number">0</span><span class="number">-3</span>]</div></pre></td></tr></table></figure><p>还可以优化一下，合并前面的两个多选分支，得到：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">01</span>]?[<span class="number">0</span><span class="number">-9</span>]|<span class="number">2</span>[<span class="number">0</span><span class="number">-3</span>]</div></pre></td></tr></table></figure><p><strong>方法二</strong>：分类逻辑为第二个数字，可以分为两部分：[0-3]和[4-9]。为什么这么分？看看下面这个图就知道了，[0-3]多了一行（以2为第一个数字）：</p><p><img src="//misc.aotu.io/Newcandy/2016-12-07-regexp-practice/24hour.png" alt="24hour"></p><p>因此有两个多选分支，结果为：<br></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">012</span>]?[<span class="number">0</span><span class="number">-3</span>]|[<span class="number">01</span>]?[<span class="number">4</span><span class="number">-9</span>]</div></pre></td></tr></table></figure><p></p><ul><li>分钟部分</li></ul><p>分钟数比较简单，第一个数范围在0-5之间，第二个数在0-9之间，因此得到分钟数为:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">0-5</span>][<span class="symbol">0-9</span>]</div></pre></td></tr></table></figure><ul><li>最后的结果：</li></ul><p>小时部分用(?:)包起来，起到一个分组的作用，且不保存匹配项；<br>冒号、分钟数拼起来；<br>最后加上一个分界<code>\b</code>表示单词的开始或结束，得到最终的结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/\b(?:[<span class="string">01</span>]?[<span class="string">0-9</span>]|2[<span class="string">0-3</span>]):[<span class="string">0-5</span>][<span class="symbol">0-9</span>]\b/</div><div class="line">// 或者</div><div class="line">/\b(?:[<span class="string">012</span>]?[<span class="string">0-3</span>]|[<span class="string">01</span>]?[<span class="string">4-9</span>]):[<span class="string">0-5</span>][<span class="symbol">0-9</span>]\b/</div></pre></td></tr></table></figure><ul><li>验证：</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var reg = /\b(?:[<span class="string">01</span>]?[<span class="string">0-9</span>]|2[<span class="string">0-3</span>]):[<span class="string">0-5</span>][<span class="symbol">0-9</span>]\b/;</div><div class="line">'现在是09:49点'.match(reg);	// ["09:49"]</div><div class="line">'现在是009:490点'.match(reg);	 // null</div></pre></td></tr></table></figure><p>其实这个结果不能说完全正确，首先你要明白这个正则用在什么地方，比如是数据验证或者<br>复杂的字符串搜寻替换。</p><p>情景一：填写表单中的字符串必须为24小时制的时间，那么可能第一个<code>\b</code>需要改成^，第二个<code>\b</code>改成<code>$</code>。</p><p>情景二：用于复杂的字符串搜寻替换时，可能也会匹配这样子的字符串如’跑步用时19:50’,明显的，’19:50’表示19分50秒，而不是表示24小时制的时间19点50分。</p><h2 id="匹配IP地址" class="post-heading"><a href="#匹配IP地址" class="headerlink" title="匹配IP地址"></a>匹配IP地址<a class="post-anchor" href="#匹配IP地址" aria-hidden="true"></a></h2><p>IP地址的规则：点号分开的四个字段，每个字段在0-255之间。</p><ul><li>第一步：</li></ul><p>如果一个字段是一个数或两个数，肯定是在0-255的范围内的；<br>如果三位数，那么以0或者1开头的三位数也是合法的，即000-199。</p><p>从上面的陈述中我们就可以得到三个多选分支：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">\d</span>|<span class="symbol">\d</span><span class="symbol">\d</span>|[01]<span class="symbol">\d</span><span class="symbol">\d</span></div></pre></td></tr></table></figure><p>我们稍微合并一下这三个多选分支，得到：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[01]?<span class="symbol">\d</span><span class="symbol">\d</span>?</div></pre></td></tr></table></figure><ul><li>第二步：</li></ul><p>我们再来看以2开头的三位数：</p><p>第二位数小于5的时候，第三位数范围[0-9]都可以；第二位数等于5的时候，第三位数范围[0-5] ，因此得到两个多选分支：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]</div></pre></td></tr></table></figure><ul><li>第三步：</li></ul><p>前两步合并起来，得到一个字段0-255的表示方法：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">01</span>]?\d\d?|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]</div></pre></td></tr></table></figure><ul><li>第四步：</li></ul><p>四个字段合并起来，IP地址正则如下：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/^(?:[01]?<span class="symbol">\d</span><span class="symbol">\d</span>?|2[0-4]<span class="symbol">\d</span>|25[0-5])<span class="symbol">\.</span>(?:[01]?<span class="symbol">\d</span><span class="symbol">\d</span>?|2[0-4]<span class="symbol">\d</span>|25[0-5])<span class="symbol">\.</span>(?:[01]?<span class="symbol">\d</span><span class="symbol">\d</span>?|2[0-4]<span class="symbol">\d</span>|25[0-5])<span class="symbol">\.</span>(?:[01]?<span class="symbol">\d</span><span class="symbol">\d</span>?|2[0-4]<span class="symbol">\d</span>|25[0-5])$/</div></pre></td></tr></table></figure><p>点号要转义一下，^和$需要加上，否则可能匹配52123.3.22.993，因为其中的123.3.22.99是符合的。(?:)起到分组的作用，且不保存匹配项。</p><p>一些测试结果：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var reg = /^(?:[<span class="number">01</span>]?\d\d?|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])\.(?:[<span class="number">01</span>]?\d\d?|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])\.(?:[<span class="number">01</span>]?\d\d?|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])\.(?:[<span class="number">01</span>]?\d\d?|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])$/;</div><div class="line"></div><div class="line"><span class="string">'123.11.22.33.44'</span>.match(reg); // null</div><div class="line"><span class="string">'52123.3.22.993'</span>.match(reg);  // null</div><div class="line"><span class="string">'123.11.22.33'</span>.match(reg);  // [<span class="string">"123.11.22.33"</span>]</div><div class="line"><span class="string">'0.0.0.0'</span>.match(reg); 	// [<span class="string">"0.0.0.0"</span>]</div></pre></td></tr></table></figure><p>虽然0.0.0.0是合法的，但它是非法的IP地址，使用正则的否定顺序环视功能(零宽负向先行断言)，可加上(?!0+.0+.0+.0+$) ：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var reg = /^(?!<span class="number">0</span>+<span class="number">.0</span>+<span class="number">.0</span>+<span class="number">.0</span>+$)(?:[<span class="number">01</span>]?\d\d?|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])\.(?:[<span class="number">01</span>]?\d\d?|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])\.(?:[<span class="number">01</span>]?\d\d?|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])\.(?:[<span class="number">01</span>]?\d\d?|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])$/;</div><div class="line"></div><div class="line"><span class="string">'123.11.22.33'</span>.match(reg); // [<span class="string">"123.11.22.33"</span>]</div><div class="line"><span class="string">'0.0.0.0'</span>.match(reg);  // null</div></pre></td></tr></table></figure><h2 id="匹配分隔符之内的文本" class="post-heading"><a href="#匹配分隔符之内的文本" class="headerlink" title="匹配分隔符之内的文本"></a>匹配分隔符之内的文本<a class="post-anchor" href="#匹配分隔符之内的文本" aria-hidden="true"></a></h2><h3 id="常见的匹配要求" class="post-heading"><a href="#常见的匹配要求" class="headerlink" title="常见的匹配要求"></a>常见的匹配要求<a class="post-anchor" href="#常见的匹配要求" aria-hidden="true"></a></h3><ul><li>匹配<code>/*</code>和<code>*/</code>之间的css注释。</li><li>匹配引文字符串””，且容许其中包含转义的引号\”。</li><li>匹配一个HTML tag，也就是尖括号之内的文本，例如<body>。</body></li></ul><h3 id="匹配思路的步骤" class="post-heading"><a href="#匹配思路的步骤" class="headerlink" title="匹配思路的步骤"></a>匹配思路的步骤<a class="post-anchor" href="#匹配思路的步骤" aria-hidden="true"></a></h3><ol><li>匹配起始分隔符。</li><li>匹配正文（即结束分隔符之前的所有文本）。</li><li>匹配结束分隔符。</li></ol><h3 id="容许引文字符串中出现转义引号" class="post-heading"><a href="#容许引文字符串中出现转义引号" class="headerlink" title="容许引文字符串中出现转义引号"></a>容许引文字符串中出现转义引号<a class="post-anchor" href="#容许引文字符串中出现转义引号" aria-hidden="true"></a></h3><h4 id="大概思路" class="post-heading"><a href="#大概思路" class="headerlink" title="大概思路"></a>大概思路<a class="post-anchor" href="#大概思路" aria-hidden="true"></a></h4><p>描述：起始分隔符和结束分隔符都是<code>&quot;</code>,且正文中容许出现转义之后的引号<code>\&quot;</code>。</p><p>简单情况分析：</p><p>举例：匹配类似 <code>I &quot;start \&quot;x3\&quot; end&quot; U</code> 文本的 <code>&quot;start \&quot;x3\&quot; end&quot;</code> 引文字符串，注意<code>\&quot;</code>属于转义引号。</p><ul><li>起始分隔符和结束分隔符都是<code>&quot;</code>。</li><li>字符不是引号，肯定是正文。即<code>[^&quot;]</code>表示不是引号的其他任意字符。</li><li>引号<code>&quot;</code>前面有反斜线\，且被反斜线\转义，则也属于正文。例如<code>start\&quot;</code>引号的前面有<strong>一个</strong>反斜线，那么这个引号也属于正文。即(?&lt;=\)”表示匹配一个引号，它的前面有一个<code>\</code>，注意正则的反斜线也要用<code>\</code>来转义一下,因为\是特殊字符。</li></ul><p>用非捕获分组<code>(?:)</code>将<code>[^&quot;]|(?&lt;=\\)&quot;</code>括起来，给个量词<code>*</code>，表示匹配正文0次或多次。<br>因此可以写出正则表达式： <code>/&quot;(?:[^&quot;]|(?&lt;=\\)&quot;)*&quot;/</code><br>注意：ES7才支持逆序环视<code>(?&lt;=)</code></p><h4 id="验证1：" class="post-heading"><a href="#验证1：" class="headerlink" title="验证1："></a>验证1：<a class="post-anchor" href="#验证1：" aria-hidden="true"></a></h4><p>验证正则：<code>/&quot;(?:[^&quot;]|(?&lt;=\\)&quot;)*&quot;/</code></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">'I</span> <span class="string">"start \"</span>x3\<span class="string">" end"</span> U'.match(/<span class="string">"(?:[^"</span>]|(?&lt;=\\)<span class="string">")*"</span>/);</div><div class="line">// 结果： [<span class="string">""</span>start <span class="string">""</span>]</div><div class="line"></div><div class="line"><span class="symbol">'I</span> <span class="string">"start \\"</span>x3\\<span class="string">" end"</span> U'.match(/<span class="string">"(?:[^"</span>]|(?&lt;=\\)<span class="string">")*"</span>/);</div><div class="line">// 结果：[<span class="string">""</span>start \<span class="string">"x3\"</span> <span class="keyword">end</span><span class="string">""</span>]</div></pre></td></tr></table></figure><p>为什么第2个才是对的呢？我们看一下返回的input属性就了解了：</p><p><img src="//misc.aotu.io/Newcandy/2016-12-07-regexp-practice/reg_input.png" alt="input属性"></p><h4 id="验证2：" class="post-heading"><a href="#验证2：" class="headerlink" title="验证2："></a>验证2：<a class="post-anchor" href="#验证2：" aria-hidden="true"></a></h4><p>验证正则：<code>/&quot;(?:[^&quot;]|(?&lt;=\\)&quot;)*&quot;/</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">'I "<span class="keyword">start</span> \\<span class="string">"x3\\\\"</span> <span class="keyword">end</span><span class="string">" U'.match(/"</span>(?:[^<span class="string">"]|(?&lt;=\\)"</span>)*<span class="string">"/);</span></div><div class="line">// 结果与期望不符合：[""start \"x3\\" <span class="keyword">end</span><span class="string">""</span>]</div><div class="line">// 期望：[<span class="string">""</span><span class="keyword">start</span>\<span class="string">"x3\\"</span>]</div><div class="line">// 注意返回的<span class="keyword">input</span>属性为：<span class="string">"I "</span><span class="keyword">start</span> \<span class="string">"x3\\"</span> <span class="keyword">end</span><span class="string">" U"</span></div></pre></td></tr></table></figure><p>引号”前面有反斜线\，但是这个反斜线不是转义引号的，那么引号就不应该属于正文，而是属于结束分隔符。<br>什么情况反斜线\不转义引号呢？<br>这个反斜线\本身就是被转义的情况。</p><p>上面的结果按照预期结果应该返回 <code>[&quot;&quot;start\&quot;x3\\&quot;]</code>，但是现在多了<code>end&quot;</code>。<br>因此验证这个正则表达式不正确。</p><p>也就是说，正文中可出现转义的字符，因此得出正则<code>\\.</code> ，注意第一个<code>\</code>表示转义第二个<code>\</code>,点表示匹配除换行符 \n 之外的任何单个字符）,例如可以匹配<code>\+</code>或者<code>\\</code>。而且转义的字符已经包含了<code>\&quot;</code>的情况，因此正则<code>(?&lt;=\\)&quot;</code>可以不用写了，且替换成<code>\\.</code>。</p><p>因此改正后的正则：<code>/&quot;(?:\\.|[^&quot;])*&quot;/</code></p><p>你可能注意到了，我把[^”]和\.的位置调换一下，后面的验证3会讲到为什么要这么做。</p><h4 id="验证3：" class="post-heading"><a href="#验证3：" class="headerlink" title="验证3："></a>验证3：<a class="post-anchor" href="#验证3：" aria-hidden="true"></a></h4><p>验证正则：<code>/&quot;(?:\\.|[^&quot;])*&quot;/</code> 和 <code>/&quot;(?:[^&quot;]|\\.)*&quot;/</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">'I "<span class="keyword">start</span> \\<span class="string">"x3\\\\"</span> <span class="keyword">end</span><span class="string">" U'.match(/"</span>(?:\\.|[^<span class="string">"])*"</span>/);</div><div class="line">// 结果与期望符合：[""<span class="keyword">start</span> \<span class="string">"x3\\""]</span></div><div class="line">// input: "I <span class="string">"start \"x3\\"</span> <span class="keyword">end</span><span class="string">" U"</span></div><div class="line"></div><div class="line">// [^<span class="string">"]和\\.的位置调换</span></div><div class="line">'I "<span class="keyword">start</span> \\<span class="string">"x3\\\\"</span> <span class="keyword">end</span><span class="string">" U'.match(/"</span>(?:[^<span class="string">"]|\\.)*"</span>/);</div><div class="line">// 结果与期望不符合：[""<span class="keyword">start</span> \<span class="string">""</span>]</div><div class="line">// 期望：[<span class="string">""</span><span class="keyword">start</span>\<span class="string">"x3\\"</span>]</div><div class="line">// <span class="keyword">input</span>: <span class="string">"I "</span><span class="keyword">start</span> \<span class="string">"x3\\"</span> <span class="keyword">end</span><span class="string">" U"</span></div></pre></td></tr></table></figure><p><code>[^&quot;]</code>和<code>\\.</code>的位置调换后，结果与期望不符合。那是因为<code>[^&quot;]</code>匹配<code>start \</code>后，遇到紧接着的<code>&quot;</code>不匹配，交给后面的多选分支<code>\\.</code>，也不匹配，又刚好结束分隔符是<code>&quot;</code>,导致匹配成功，结束匹配。</p><p>因此两个正则之间 正确的正则是 <code>/&quot;(?:\\.|[^&quot;])*&quot;/</code></p><h4 id="验证4：" class="post-heading"><a href="#验证4：" class="headerlink" title="验证4："></a>验证4：<a class="post-anchor" href="#验证4：" aria-hidden="true"></a></h4><p>验证：<code>/&quot;(?:\\.|[^&quot;])*&quot;/</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">'I "start \\"x3\\" end U'</span>.<span class="keyword">match</span>(/<span class="string">"(?:\\.|[^"</span>])*<span class="comment">"/);</span></div><div class="line">// 结果与期望不符合：[<span class="string">""</span>start \<span class="string">"x3\""</span>]</div><div class="line">// 注意end后面少了<span class="comment">",期望结果是null，不匹配</span></div><div class="line">// inpu<span class="variable">t:</span> <span class="string">"I "</span>start \<span class="string">"x3\" end U"</span></div></pre></td></tr></table></figure><p>上面的字符串 <code>&quot;start\&quot;x3\&quot;</code> 其实是没有结束分隔符的，但是还是匹配了。那是因为正则<code>[^&quot;]</code>和<code>\\.</code> 一起作用,导致匹配到了文本U末尾，后续想找结束分隔符的时候，结果却找不到，所以只能回溯文本去找结束分隔符，最后找到了 <code>x3\</code>后面的引号，匹配成功，结束匹配。</p><p>回溯会导致不期望的结果，由于是卡在多选分支上出错的，因此猜测多选分支<code>|</code>匹配内容出现重叠。</p><p>你想想，如果符合正文的反斜线，不是以<code>[^&quot;]</code>方式匹配,而是以<code>\\.</code>的方式匹配，那就不会把好好的<code>\&quot;</code>拆开来匹配了。</p><p>综上所述，一定要让反斜线是以<code>\\.</code>的方式匹配，字符串里的反斜杆不能以<code>[^&quot;]</code>方式匹配。<br>因此将<code>[^&quot;]</code>改成<code>[^\\&quot;]</code>。这样子就可以确保正确识别正文特殊的<code>\&quot;</code>和结束分隔符<code>&quot;</code>了。</p><p>注意：很多字符在[]都会失去本来的意义，但是反斜杠字符 <code>\</code> 仍为转义字符。若要匹配反斜杠字符，请使用两个反斜杠 <code>\\</code>。</p><p>改正的正则：<code>/&quot;(?:\\.|[^\\&quot;])*&quot;/</code></p><h4 id="验证5" class="post-heading"><a href="#验证5" class="headerlink" title="验证5"></a>验证5<a class="post-anchor" href="#验证5" aria-hidden="true"></a></h4><p>验证：<code>/&quot;(?:\\.|[^\\&quot;])*&quot;/</code></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">'I "start \\"x3\\" end U'</span>.match(/<span class="string">"(?:\\.|[^\\"</span>])*<span class="string">"/);</span></div><div class="line">// 结果与期望符合：null</div><div class="line">// input: "I <span class="string">"start \"</span>x3\<span class="string">" end"</span> U<span class="string">"</span></div><div class="line"></div><div class="line"></div><div class="line">'I "<span class="keyword">start</span> \\<span class="string">"x3\\"</span> <span class="keyword">end</span><span class="string">" U'.match(/"</span>(?:\\.|[^\\<span class="string">"])*"</span>/);</div><div class="line">// 结果与期望符合：[<span class="string">""</span><span class="keyword">start</span> \<span class="string">"x3\"</span> <span class="keyword">end</span><span class="string">""</span>]</div><div class="line">// input: <span class="string">"I "</span><span class="keyword">start</span> \<span class="string">"x3\"</span> <span class="keyword">end</span><span class="string">" U"</span></div></pre></td></tr></table></figure><p>为了优化，我们可以把<code>[^\\&quot;]</code>放在前面，因为普通字符的匹配可能性更大。<br>注意：优化正则提高效率最需要考虑的问题：改动是否会影响匹配。只有在排序与匹配成功无关时才不会影响准确性，才能重新安排多选分支的顺序。</p><p>优化后的正则：<code>/&quot;(?:[^\\&quot;]|\\.)*&quot;/</code></p><h3 id="HTML-Tag" class="post-heading"><a href="#HTML-Tag" class="headerlink" title="HTML Tag"></a>HTML Tag<a class="post-anchor" href="#HTML-Tag" aria-hidden="true"></a></h3><p>经历了容许引文字符串中出现转义引号的例子分析，瞬间觉得这个容易了许多。</p><p>描述与要求：匹配类似<code>&lt;input name=123 value=&quot;&gt;&quot; &gt;</code>的HTML标签，起始分隔符是<code>&lt;</code>，结束分隔符是<code>&gt;</code>，且HTML 标签属性值中可以出现<code>&gt;</code>。</p><p>起始分隔符和结束分隔符都是明确的，我们来分类一下正文。</p><ul><li>双引号引用文本</li><li>单引号引用文本</li><li>除了&gt;和引号之外的任意字符</li></ul><p>可能你会当心单双引号引用文本，会像“容许引文字符串中出现转义引号”那么复杂。幸好是HTML Tag的属性值中不允许出现转义引号，因为平常的转义符号<code>\</code>变成了普通字符。</p><p>根据三种情况，分别写出三个正则：</p><ul><li><code>&quot;[^&quot;]*&quot;</code></li><li><code>&#39;[^&#39;]*&#39;</code></li><li><code>[^&#39;&quot;&gt;]</code></li></ul><p>好了，用多选分支连起来<code>&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;]</code>，再用非捕获分组(?:)将多选分支括起来，如<code>(?:&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])</code>，用<code>*</code>表示匹配任意次，最后前后加上开始结束分隔符，搞定：</p><p><code>/&lt;(?:&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])*&gt;/</code></p><p>验证：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'&lt;input name=123 value="&gt;" &gt;'</span>.match(<span class="regexp">/&lt;(?:"[^"]*"|'[^']*'|[^'"&gt;])*&gt;/</span>)</div><div class="line"><span class="comment">// 结果： ["&lt;input name=123 value="&gt;" &gt;"]</span></div></pre></td></tr></table></figure><h2 id="体会：" class="post-heading"><a href="#体会：" class="headerlink" title="体会："></a>体会：<a class="post-anchor" href="#体会：" aria-hidden="true"></a></h2><p>看到没有，几乎每个正则都包含多选分支，只要你懂得将数据分类，离成功就不远了。哈哈哈哈哈。</p><h2 id="参考" class="post-heading"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="post-anchor" href="#参考" aria-hidden="true"></a></h2><p>《精通正则表达式》<br><a href="http://imweb.io/topic/56e804ef1a5f05dc50643106" target="_blank" rel="external">http://imweb.io/topic/56e804ef1a5f05dc50643106</a></p><div class="post-tags" style="display:none"><a href="/tags/正则表达式/">正则表达式</a> <a href="/tags/regexp/">regexp</a> <a href="/tags/javascript/">javascript</a> <a href="/tags/回溯/">回溯</a> <a href="/tags/匹配美元/">匹配美元</a> <a href="/tags/匹配24小时制的时间/">匹配24小时制的时间</a> <a href="/tags/匹配IP地址/">匹配IP地址</a> <a href="/tags/匹配分隔符之内的文本/">匹配分隔符之内的文本</a> <a href="/tags/多选分支/">多选分支</a></div><div class="post-categories" style="display:none"><a href="/cates/Web开发/">Web开发</a></div><div class="post-revision"><i class="fa fa-clock-o"></i> <time class="post-updated" datetime="2016-12-22T09:53:25.578Z">上次更新：2016-12-22 17:53:25</time></div></div><div class="post-nav"><div class="post-nav-next"><a href="/notes/2016/12/08/vim-4/" title="vim给代码行尾加分号的几种方法">vim给代码行尾加分号的几种方法 <i class="fa fa-chevron-right"></i></a></div><div class="post-nav-prev"><a href="/notes/2016/12/04/firewatcher-appreciation/" title="源码赏析 - 1K的Firewatch游戏"><i class="fa fa-chevron-left"></i> 源码赏析 - 1K的Firewatch游戏</a></div></div><div class="post-comments" id="comments"><div class="ds-thread" data-thread-key="bm90ZXMvMjAxNi8xMi8wNy9yZWdleHAtcHJhY3RpY2Uv" data-title="正则表达式实践篇" data-url="https://demo.lilidong.cn/notes/2016/12/07/regexp-practice/index.html"></div><script type="text/javascript">var duoshuoQuery={short_name:"Jackieli"};!function(){var t=document.createElement("script");t.id="duoshuo-script",t.type="text/javascript",t.async=!0,t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}()</script></div></article></div><aside class="mod-side" id="sidebar"><div class="mod-side-sec aotuwx"><img class="aotuwx-qrcode" src="/img/qrcode.jpg" alt="关注我们"><div class="aotuwx-slogan">每周五推送精选技术文章</div></div><div class="mod-side-sec works"><div class="mod-side-sec-hd"><h2>服务/产品</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="//cases.aotu.io/mobi/maga.html" target="_blank" title="拇指期刊">拇指期刊</a></li><li><a href="//athena.aotu.io/" target="_blank" title="Athena">Athena</a></li><li><a href="//guide.aotu.io/" target="_blank" title="前端代码规范">前端代码规范</a></li><li><a href="//halojs.aotu.io/" target="_blank" title="HaloJS">HaloJS</a></li><li><a href="//sign.aotu.io/" target="_blank" title="邮件签名工具">邮件签名工具</a></li><li><a href="//mac.aotu.io/" target="_blank" title="MAC全栈环境">MAC全栈环境</a></li></ul></div></div><div class="mod-side-sec favlinks"><div class="mod-side-sec-hd"><h2>友情链接</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="https://jdc.jd.com" target="_blank" title="京东设计中心">JDC京东设计中心</a></li><li><a href="http://fex.baidu.com" target="_blank" title="百度Web前端研发部">百度FEX</a></li><li><a href="http://taobaofed.org" target="_blank" title="淘宝前端团队">淘宝FED</a></li><li><a href="http://tgideas.qq.com" target="_blank" title="腾讯互娱设计中心">TGIdeas</a></li><li><a href="http://isux.tencent.com" target="_blank" title="腾讯SNG设计中心">ISUX</a></li><li><a href="http://cdc.tencent.com" target="_blank" title="腾讯用户研究与体验设计中心">CDC</a></li><li><a href="http://ued.ctrip.com" target="_blank" title="携程设计委员会">携程UED</a></li></ul></div></div></aside></div></div><div class="mod-backtop" id="backTop"><i class="fa fa-long-arrow-up"></i></div><footer class="mod-ft" id="footer"><div class="grid"><ul class="mod-ft-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="https://github.com/jackieli-json/jackieli-json.github.io" target="_blank"><i class="fa fa-github-alt"></i></a></li></ul><div class="mod-ft-sec mod-ft-copyright"><p>Designed by <a href="http://lilidong.cn" target="_blank">西门互联</a></p><p>Copyright &copy; 2016. All Rights Reserved.</p></div></div></footer><script src="/js/bundle/core.js"></script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?e850b980d029480b092fdd7503c3f8de";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><style>#cnzz_stat_icon_1258539944{display:none}</style><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?" https://":" http://";document.write(unescape("%3Cspan id='cnzz_stat_icon_1258539944'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s11.cnzz.com/z_stat.php%3Fid%3D1258539944' type='text/javascript'%3E%3C/script%3E"))</script></body></html>