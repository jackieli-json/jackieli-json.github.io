<!DOCTYPE html><html class="theme-lattice"><head><meta charset="utf-8"><title>Webpack 实用配置技巧 | 西门互联「西门互联」</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="西门互联"><meta name="designer" content="西门互联"><meta name="rating" content="general"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="index, follow"><meta name="keywords" content="Webpack 配置技巧,模块打包工具,Webpack,西门互联,前端,个人博客"><link rel="canonical" href="https://demo.lilidong.cn/notes/2016/11/14/webpack-tips/index.html"><link rel="apple-touch-icon" sizes="57x57" href="/img/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="114x114" href="/img/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="72x72" href="/img/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="144x144" href="/img/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="60x60" href="/img/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="120x120" href="/img/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="152x152" href="/img/apple-touch-icon-152x152.png"><link rel="icon" type="image/png" href="/img/favicon-230x230.png" sizes="230x230"><link rel="icon" type="image/png" href="/img/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/png" href="/img/favicon-16x16.png" sizes="16x16"><link rel="icon" type="image/png" href="/img/favicon-32x32.png" sizes="32x32"><meta name="msapplication-TileColor" content="#2f83cd"><meta name="msapplication-TileImage" content="/img/mstile-144x144.png"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/atom.xml" title="西门互联"><meta name="description" content="前言Webpack做了什么
一句话简单来解释就是处理模块依赖，并将它们合并成可用的静态资源。
为什么选Webpack
模块打包工具有很多，Webpack的特点是它依赖的模块可以是js文件，也可以是css文件，只要配置对应的webpack-loader(加载器)，.coffee、.sass、.jade等等任意的静态资源文件都可以被引用，并解析。

例如：我在项目中使用Vue框架，在配置官方提供的lo"><meta property="og:type" content="article"><meta property="og:title" content="Webpack 实用配置技巧"><meta property="og:url" content="https://demo.lilidong.cn/notes/2016/11/14/webpack-tips/index.html"><meta property="og:site_name" content="西门互联"><meta property="og:description" content="前言Webpack做了什么
一句话简单来解释就是处理模块依赖，并将它们合并成可用的静态资源。
为什么选Webpack
模块打包工具有很多，Webpack的特点是它依赖的模块可以是js文件，也可以是css文件，只要配置对应的webpack-loader(加载器)，.coffee、.sass、.jade等等任意的静态资源文件都可以被引用，并解析。

例如：我在项目中使用Vue框架，在配置官方提供的lo"><meta property="og:updated_time" content="2016-12-22T09:53:25.570Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Webpack 实用配置技巧"><meta name="twitter:description" content="前言Webpack做了什么
一句话简单来解释就是处理模块依赖，并将它们合并成可用的静态资源。
为什么选Webpack
模块打包工具有很多，Webpack的特点是它依赖的模块可以是js文件，也可以是css文件，只要配置对应的webpack-loader(加载器)，.coffee、.sass、.jade等等任意的静态资源文件都可以被引用，并解析。

例如：我在项目中使用Vue框架，在配置官方提供的lo"><meta name="twitter:site" content="o2circle"><script>var App={root:"/",isHome:!1,isCate:!1,isTag:!1}</script></head><body class="page-post-detail"><div class="mod-hd"><div class="grid"><div class="mod-logo"><a href="/index.html" title="西门互联">西门互联</a></div><span class="mod-hd-toggle" id="J_hdToggle"><i class="fa fa-bars"></i></span><div class="mod-hd-main"><div class="mod-hd-inner"><nav class="mod-nav"><ul class="mod-nav-list"><li class="main-nav-item"><a href="/index.html" class="main-nav-link">首页</a></li><li class="main-nav-item"><a href="/about/" class="main-nav-link">关于</a></li><li class="main-nav-item"><a href="/join/" class="main-nav-link">加入</a></li></ul></nav><div class="mod-search"><a class="fa fa-search mod-search-ico" id="J_searchTrigger" title="搜索"></a><form id="J_searchForm" method="get" class="mod-search-form" action="/search/"><input type="text" name="query" class="mod-search-ipt" id="J_searchInput" placeholder="搜索"></form></div></div></div></div></div><div class="mod-container"><div class="grid"><div class="mod-main"><article class="post"><header class="post-hd"><h2 class="post-tit">Webpack 实用配置技巧</h2><div class="post-meta">by <a target="_blank" href="https://github.com/Simbachen" class="post-author">Simba</a> on <span>2016-11-14</span></div><p class="post-subtit" style="display:none"><i class="fa fa-quote-left"></i>如果你准备在自己的生产项目中使用Webpack，本文肯定会对你有所帮助！</p><span style="display:none" id="busuanzi_value_page_pv"></span></header><div class="post-cover"><img src="http://ww3.sinaimg.cn/large/66f2e5a7jw1f9n00j2uwnj20p00dwt9n.jpg" alt="Webpack 实用配置技巧"></div><div class="post-content"><h3 id="前言" class="post-heading"><a href="#前言" class="headerlink" title="前言"></a>前言<a class="post-anchor" href="#前言" aria-hidden="true"></a></h3><p><strong>Webpack做了什么</strong></p><p>一句话简单来解释就是处理模块依赖，并将它们合并成可用的静态资源。</p><p><strong>为什么选Webpack</strong></p><p>模块打包工具有很多，Webpack的特点是它依赖的模块可以是js文件，也可以是css文件，只要配置对应的webpack-loader(加载器)，.coffee、.sass、.jade等等任意的静态资源文件都可以被引用，并解析。</p><blockquote><p>例如：我在项目中使用Vue框架，在配置官方提供的loader后，就可以直接在js中依赖.vue后缀的单文件组件了。</p></blockquote><h3 id="上手" class="post-heading"><a href="#上手" class="headerlink" title="上手"></a>上手<a class="post-anchor" href="#上手" aria-hidden="true"></a></h3><p><strong>安装</strong></p><ol><li>使用npm init命令来创建一个package.json文件</li><li><p>安装Webpack，推荐只安装在当前项目中作为依赖</p><p>npm install webpack –save</p></li></ol><p><strong>添加一个配置文件 webpack.config.js</strong></p><pre><code>module.exports = {
    entry: &quot;./entry.js&quot;,
    output: {
        path: __dirname,
        filename: &quot;bundle.js&quot;
    },
    module: {
        loaders: [
            { test: /\.css$/, loader: &quot;style!css&quot; }
        ]
    }
};
</code></pre><p><strong>执行webpack命令</strong></p><blockquote><p>如果全局安装了Webpack的话,那么直接在当前项目执行webpack命令就可以依赖上述webpack.config.js文件中的配置，分析entry.js中的依赖，打包输出bundle.js</p></blockquote><p>我使用npm scripts来启动任务，在package.json中添加：</p><pre><code>{
    ...
    &quot;scripts&quot;: {
        &quot;build&quot;: &quot;NODE_ENV=production webpack --watch&quot;
    }
    ...
}
</code></pre><p>执行npm run build。其中–watch参数表示持续的监听文件变化进行打包。</p><h3 id="入口文件配置" class="post-heading"><a href="#入口文件配置" class="headerlink" title="入口文件配置"></a>入口文件配置<a class="post-anchor" href="#入口文件配置" aria-hidden="true"></a></h3><p><strong>配置多个入口文件</strong></p><pre><code>module.exports = {
    entry: {
        entry1_bundle: &quot;./entry1.js&quot;,
        entry2_bundle: &quot;./entry2.js&quot;
    },
    output: {
        path: __dirname,
        filename: &quot;[name].js&quot;
    },
    module: {
        loaders: [
            { test: /\.css$/, loader: &quot;style!css&quot; }
        ]
    }
};
</code></pre><p>在这个配置文件中有两个入口文件，输出的时候[name]会被替换为入口中配置的entry1_bundle和entry2_bundle</p><p><strong>使用glob方式配置</strong></p><pre><code>var path = require(&apos;path&apos;),
      glob = require(&apos;glob&apos;)  //需安装glob模块依赖

  function getEntries (globPath) {
  var files = glob.sync(globPath);
  var _entries = {}, entry, dirname, basename;

  for (var i = 0; i &lt; files.length; i++) {
      entry = files[i];
      dirname = path.dirname(entry);
      basename = path.basename(entry, &apos;.js&apos;);
      _entries[path.join(dirname, basename)] = &apos;./&apos; + entry;
  }
  return _entries;
  }
</code></pre><p>执行getEntries(‘*.js’)就会遍历到目录下全部的js文件做为入口文件配置。</p><h3 id="使用插件" class="post-heading"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件<a class="post-anchor" href="#使用插件" aria-hidden="true"></a></h3><p>目前我有用到三个插件：CommonsChunkPlugin，UglifyJsPlugin，以及一个我自己定义的插件</p><pre><code>module.exports = {
    // plugins 字段传入一个数组，里面是实例化后的各种插件
    plugins: [new webpack.optimize.CommonsChunkPlugin({
          name: &apos;vendor&apos;,
          minChunks: 3
    }),
    new webpack.optimize.UglifyJsPlugin([options]),

    ...
    ],
    entry: {
        entry1_bundle: &quot;./entry1.js&quot;,
        entry2_bundle: &quot;./entry2.js&quot;
    },
    ...
};
</code></pre><p><strong>提取公用资源</strong></p><p>为了便于使用缓存，我通过CommonsChunkPlugin这个插件将公用部分提取出来。</p><p>上述配置会自动的将被3个及以上入口文件引用的资源提取出来到一个新的文件vendor.js中。我们通常不希望公用的内容发生不预知的变化，这样配置就可以将希望提取出来的内容显性的配置在config文件中：</p><pre><code>entry: {
  vendor: [&quot;vue&quot;, &quot;other-lib&quot;],
  ...
}
new CommonsChunkPlugin({
  name: &quot;vendor&quot;,
  // 将minChunks设置为无穷大，就不会有不期望的内容进入vendor了
  minChunks: Infinity,

})
</code></pre><p><strong>只在生产环境下启用UglifyJs插件</strong></p><pre><code>var plugins = [new webpack.optimize.CommonsChunkPlugin([options])]
// npm scripts 配置的参数可以用上了
if(process.env.NODE_ENV == &apos;production&apos;){
  plugins.push(new webpack.optimize.UglifyJsPlugin({
    compress: {
      warnings: false
    }
  }))
}
</code></pre><p>关于UglifyJs的使用就不介绍了，参考<a href="https://github.com/mishoo/UglifyJS2#usage" target="_blank" rel="external">UglifyJS2</a>。</p><p><strong>自定义插件</strong></p><p>Webpack提供的插件已足够使用，不过针对不同的业务，我们可能需要定制一些功能，例如我所定制的功能就是在编译资源的同时生成一份用于上传到服务器的md5版本号配置文件。</p><p>来一个简单的小栗子，如何开始写一个Webpack插件：</p><pre><code>var chunkCombo = function(){};
    chunkCombo.prototype.apply = function(compiler, callback){
  compiler.plugin(&quot;emit&quot;, function(compilation, callback){
      compilation.chunks.map(function(chunk, key){

        var filename = chunk.name + &apos;.shtml&apos;;
        var content = chunk.hash.slice(0,8);

        // 生成一个对应的新文件存储md5值
        compilation.assets[filename] = {
          source: function() {
              return content;
            },
            size: function() {
              return Buffer.byteLength(content, &apos;utf8&apos;) 
            }
        };
      })
      callback();
  });
    }
</code></pre><p>随着项目的深度定制和优化，我们可能需要开发更多的插件。</p><h3 id="配置loaders" class="post-heading"><a href="#配置loaders" class="headerlink" title="配置loaders"></a>配置loaders<a class="post-anchor" href="#配置loaders" aria-hidden="true"></a></h3><p>有了无所不能的加载器，Webpack可以处理任何类型的静态文件</p><pre><code>module.exports = {
  entry: {
    entry1_bundle: &quot;./entry1.js&quot;,
    entry2_bundle: &quot;./entry2.js&quot;
  },
  output: {
      path: __dirname,
      filename: &quot;[name].js&quot;
  },
  module: {
      loaders: [
        { test: /\.vue$/, loader: &apos;vue-loader&apos; },
        { test: /\.css$/, loader: &apos;style-loader!css-loader&apos; },
        { test: /\.js$/, exclude: /node_modules/, loader: &quot;babel-loader&quot;},
        //加载器之间用！连接，-loader可以省略不写
        { test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;},
        { test: /\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;}
      ]
  }
  };
</code></pre><p>加载器使用前记得先通过npm安装对应的模块，并将依赖添加到package.json文件中，例如：</p><pre><code>npm install vue-loader --save
</code></pre><ul><li>vue-loader用于解析.vue单文件组件。</li><li>有了babel-loader就可以直接使用新的语法特性了。Babel的配置参见<a href="http://babeljs.io/docs/setup/#installation" target="_blank" rel="external">Using Babel</a></li></ul><h3 id="使用webpack-dev-server" class="post-heading"><a href="#使用webpack-dev-server" class="headerlink" title="使用webpack-dev-server"></a>使用webpack-dev-server<a class="post-anchor" href="#使用webpack-dev-server" aria-hidden="true"></a></h3><p>webpack-dev-server是一个轻量的node.js Express服务，通过Socket.IO来实时的通知客户端Webpack编译状态。<br>安装webpack-dev-server模块，此处不再重复，直接看配置文件：</p><pre><code>module.exports = {
  entry: {
    entry1_bundle: &quot;./entry1.js&quot;,
    entry2_bundle: &quot;./entry2.js&quot;
  },
  output: {
        path: __dirname,
        filename: &quot;bundle.js&quot;
    },
  ...
  devServer: {
      // serve 的根目录
    contentBase: _contentBase,
    port: 9000,
    // iframe模式和inline模式可选
    inline: true，
    ...
  }
  };
</code></pre><p>在package.json中添加：</p><pre><code>{
      ...
      &quot;scripts&quot;: {
        &quot;dev&quot;: &quot;NODE_ENV=dev webpack-dev-server&quot;
      }
      ...
}
</code></pre><p>执行npm run dev 命令后，服务就启动了。访问<a href="">http://localhost:9000</a>，就可以看到你的应用了。</p><p><strong>定制Express路由</strong></p><p>在inline模式下，需要手动的将用于更新的的脚本引入到页面中：</p><pre><code>module.exports = {
  entry: {
    entry1_bundle: &quot;./entry1.js&quot;,
    entry2_bundle: &quot;./entry2.js&quot;
  },
  output: {
        path: __dirname,
        filename: &quot;bundle.js&quot;
    },
  ...
  devServer: {
      // serve 的根目录
    contentBase: _contentBase,
    port: 9000,
    // iframe模式和inline模式可选
    inline: true,
    setup: function(app) {
      app.use(function(req, res, next) {
        //...
        return next();
      });
      app.get([&apos;*.shtml&apos;,&apos;*.html&apos;], function(req, res, next) {
        //...

        //将实时更新的脚本引入到页面中
        res.end(&apos;&lt;script src=&quot;http://localhost:9000/webpack-dev-server.js&quot;&gt;&lt;/script&gt;&apos;)
      })
    }
  }
  };
</code></pre><p>关于Express路由的使用，参考<a href="http://expressjs.com/en/guide/routing.html" target="_blank" rel="external">Express Routing</a></p><p>在我的项目中，我希望HTML页面在开发环境下和服务器环境下保持一致，因此我在devServer中配置了对HTML页面的解析。</p><p><strong>以上，希望我的Webpack项目配置能对你解决相关问题的时候有所帮助和启发。</strong></p><h3 id="参考资料" class="post-heading"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料<a class="post-anchor" href="#参考资料" aria-hidden="true"></a></h3><ul><li><a href="http://webpack.github.io/docs/" target="_blank" rel="external">Webpack docs</a></li><li><a href="http://expressjs.com/en/guide/routing.html" target="_blank" rel="external">Express Routing</a></li><li><a href="https://aotu.io/notes/2016/02/26/use-npm-script-instead-of-gulp/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">使用npm scripts替代gulp</a></li></ul><div class="post-tags" style="display:none"><a href="/tags/Webpack/">Webpack</a> <a href="/tags/模块打包工具/">模块打包工具</a> <a href="/tags/Webpack-配置技巧/">Webpack 配置技巧</a></div><div class="post-categories" style="display:none"><a href="/cates/Web开发/">Web开发</a></div><div class="post-revision"><i class="fa fa-clock-o"></i> <time class="post-updated" datetime="2016-12-22T09:53:25.570Z">上次更新：2016-12-22 17:53:25</time></div></div><div class="post-nav"><div class="post-nav-next"><a href="/notes/2016/11/14/booklist-for-every-programmer/" title="漫漫编程路上必读的7本书">漫漫编程路上必读的7本书 <i class="fa fa-chevron-right"></i></a></div><div class="post-nav-prev"><a href="/notes/2016/11/10/weui-wxss/" title="WeUI for 小程序 - 为微信小程序量身设计"><i class="fa fa-chevron-left"></i> WeUI for 小程序 - 为微信小程序量身设计</a></div></div><div class="post-comments" id="comments"><div class="ds-thread" data-thread-key="bm90ZXMvMjAxNi8xMS8xNC93ZWJwYWNrLXRpcHMv" data-title="Webpack 实用配置技巧" data-url="https://demo.lilidong.cn/notes/2016/11/14/webpack-tips/index.html"></div><script type="text/javascript">var duoshuoQuery={short_name:"Jackieli"};!function(){var t=document.createElement("script");t.id="duoshuo-script",t.type="text/javascript",t.async=!0,t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}()</script></div></article></div><aside class="mod-side" id="sidebar"><div class="mod-side-sec aotuwx"><img class="aotuwx-qrcode" src="/img/qrcode.jpg" alt="关注我们"><div class="aotuwx-slogan">每周五推送精选技术文章</div></div><div class="mod-side-sec works"><div class="mod-side-sec-hd"><h2>服务/产品</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="//cases.aotu.io/mobi/maga.html" target="_blank" title="拇指期刊">拇指期刊</a></li><li><a href="//athena.aotu.io/" target="_blank" title="Athena">Athena</a></li><li><a href="//guide.aotu.io/" target="_blank" title="前端代码规范">前端代码规范</a></li><li><a href="//halojs.aotu.io/" target="_blank" title="HaloJS">HaloJS</a></li><li><a href="//sign.aotu.io/" target="_blank" title="邮件签名工具">邮件签名工具</a></li><li><a href="//mac.aotu.io/" target="_blank" title="MAC全栈环境">MAC全栈环境</a></li></ul></div></div><div class="mod-side-sec favlinks"><div class="mod-side-sec-hd"><h2>友情链接</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="https://jdc.jd.com" target="_blank" title="京东设计中心">JDC京东设计中心</a></li><li><a href="http://fex.baidu.com" target="_blank" title="百度Web前端研发部">百度FEX</a></li><li><a href="http://taobaofed.org" target="_blank" title="淘宝前端团队">淘宝FED</a></li><li><a href="http://tgideas.qq.com" target="_blank" title="腾讯互娱设计中心">TGIdeas</a></li><li><a href="http://isux.tencent.com" target="_blank" title="腾讯SNG设计中心">ISUX</a></li><li><a href="http://cdc.tencent.com" target="_blank" title="腾讯用户研究与体验设计中心">CDC</a></li><li><a href="http://ued.ctrip.com" target="_blank" title="携程设计委员会">携程UED</a></li></ul></div></div></aside></div></div><div class="mod-backtop" id="backTop"><i class="fa fa-long-arrow-up"></i></div><footer class="mod-ft" id="footer"><div class="grid"><ul class="mod-ft-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="https://github.com/jackieli-json/jackieli-json.github.io" target="_blank"><i class="fa fa-github-alt"></i></a></li></ul><div class="mod-ft-sec mod-ft-copyright"><p>Designed by <a href="http://lilidong.cn" target="_blank">西门互联</a></p><p>Copyright &copy; 2016. All Rights Reserved.</p></div></div></footer><script src="/js/bundle/core.js"></script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?e850b980d029480b092fdd7503c3f8de";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><style>#cnzz_stat_icon_1258539944{display:none}</style><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?" https://":" http://";document.write(unescape("%3Cspan id='cnzz_stat_icon_1258539944'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s11.cnzz.com/z_stat.php%3Fid%3D1258539944' type='text/javascript'%3E%3C/script%3E"))</script></body></html>